const std = @import("std");
const builtin = @import("builtin");
const zgui = @import("zgui");
const colors = @import("colors.zig");
const selection = @import("selection.zig");
const edit_actions = @import("edit_actions.zig");

pub const max_tracks = 16;
pub const max_scenes = 32;
pub const beats_per_bar = 4;
pub const default_clip_bars = 4;

pub const NameField = struct {
    buf: [32]u8 = undefined,
    len: usize = 0,

    pub fn init(name: []const u8) NameField {
        var field = NameField{};
        field.set(name);
        return field;
    }

    pub fn set(self: *NameField, name: []const u8) void {
        const len = @min(name.len, self.buf.len);
        @memcpy(self.buf[0..len], name[0..len]);
        self.len = len;
    }

    pub fn get(self: *const NameField) []const u8 {
        return self.buf[0..self.len];
    }
};

pub const ClipState = enum {
    empty,
    stopped,
    queued,
    playing,
    recording,
    record_queued,
};

pub const ClipSlot = struct {
    state: ClipState = .empty,
    length_beats: f32 = default_clip_bars * beats_per_bar,
};

pub const Track = struct {
    name: NameField = .{},
    volume: f32 = 0.8,
    mute: bool = false,
    solo: bool = false,

    pub fn init(name: []const u8) Track {
        var t = Track{};
        t.name.set(name);
        return t;
    }

    pub fn setName(self: *Track, name: []const u8) void {
        self.name.set(name);
    }

    pub fn getName(self: *const Track) []const u8 {
        return self.name.get();
    }
};

pub const Scene = struct {
    name: NameField = .{},

    pub fn init(name: []const u8) Scene {
        var s = Scene{};
        s.name.set(name);
        return s;
    }

    pub fn setName(self: *Scene, name: []const u8) void {
        self.name.set(name);
    }

    pub fn getName(self: *const Scene) []const u8 {
        return self.name.get();
    }
};

/// Clipboard entry for clip copy/paste
pub const ClipboardEntry = struct {
    src_track: usize,
    src_scene: usize,
    track_offset: i32,
    scene_offset: i32,
    slot: ClipSlot,
};

pub const PianoCopyRequest = struct {
    src_track: usize,
    src_scene: usize,
    dst_track: usize,
    dst_scene: usize,
};

pub const OpenClipRequest = struct {
    track: usize,
    scene: usize,
};

pub const ClipSnapshot = struct {
    has_clip: bool = false,
    length_beats: f32 = 0,
};

pub const TrackSnapshot = struct {
    name: NameField = .{},
    volume: f32 = 0,
    mute: bool = false,
    solo: bool = false,
};

pub const SceneSnapshot = struct {
    name: NameField = .{},
};

/// Types of undo requests generated by session view operations
pub const UndoRequestKind = enum {
    clip_create,
    clip_delete,
    clip_paste,
    track_add,
    track_delete,
    scene_add,
    scene_delete,
    track_volume,
};

/// Undo request for tracking state changes
pub const UndoRequest = struct {
    kind: UndoRequestKind,
    track: usize = 0,
    scene: usize = 0,
    src_track: usize = 0,
    src_scene: usize = 0,
    length_beats: f32 = 0,
    // For clip_delete: store the old clip state
    old_clip: ClipSlot = .{},
    // For track_volume
    old_volume: f32 = 0,
    new_volume: f32 = 0,
    // For track_delete
    track_data: TrackSnapshot = .{},
    track_clips: [max_scenes]ClipSnapshot = [_]ClipSnapshot{.{}} ** max_scenes,
    // For scene_delete
    scene_data: SceneSnapshot = .{},
    scene_clips: [max_tracks]ClipSnapshot = [_]ClipSnapshot{.{}} ** max_tracks,
};

/// Single clip move for undo
pub const ClipMoveEntry = struct {
    src_track: usize,
    src_scene: usize,
    dst_track: usize,
    dst_scene: usize,
};

/// Tracks the state of an active MIDI recording session
pub const RecordingState = struct {
    track: ?usize = null,
    scene: ?usize = null,
    start_beat: f32 = 0,
    queued_at_beat: f32 = 0,
    target_length_beats: f32 = default_clip_bars * beats_per_bar, // 4 bars
    note_start_beats: [128]?f32 = [_]?f32{null} ** 128, // Track held notes
    note_start_velocities: [128]?f32 = [_]?f32{null} ** 128,
    is_new_clip: bool = false,

    pub fn isRecording(self: *const RecordingState) bool {
        return self.track != null;
    }

    pub fn reset(self: *RecordingState) void {
        self.track = null;
        self.scene = null;
        self.start_beat = 0;
        self.queued_at_beat = 0;
        self.target_length_beats = default_clip_bars * beats_per_bar;
        self.note_start_beats = [_]?f32{null} ** 128;
        self.note_start_velocities = [_]?f32{null} ** 128;
        self.is_new_clip = false;
    }
};

const StopRecordingMode = enum {
    stop,
    loop,
};

pub const SessionView = struct {
    allocator: std.mem.Allocator,

    // Grid data
    tracks: [max_tracks]Track = undefined,
    scenes: [max_scenes]Scene = undefined,
    clips: [max_tracks][max_scenes]ClipSlot = undefined,
    track_count: usize = 4,
    scene_count: usize = 8,

    // Selection - simple 2D bool array
    clip_selected: [max_tracks][max_scenes]bool = [_][max_scenes]bool{[_]bool{false} ** max_scenes} ** max_tracks,
    primary_track: usize = 0,
    primary_scene: usize = 0,
    drag_select: selection.DragSelectState = .{},

    // Clipboard
    clipboard: std.ArrayListUnmanaged(ClipboardEntry) = .{},
    clipboard_origin_track: usize = 0,
    clipboard_origin_scene: usize = 0,
    // Piano clip copy requests (processed by ui.zig)
    piano_copy_requests: [max_tracks * max_scenes]PianoCopyRequest = undefined,
    piano_copy_count: usize = 0,
    pending_piano_copies: bool = false,

    // Drag move state
    drag_moving: bool = false,
    drag_start_track: usize = 0,
    drag_start_scene: usize = 0,
    drag_target_track: ?usize = null, // Where clips will move to (preview)
    drag_target_scene: ?usize = null,
    // Cell positions for accurate ghost rendering (updated during clip rendering)
    cell_positions: [max_tracks][max_scenes][2]f32 = [_][max_scenes][2]f32{[_][2]f32{.{ 0, 0 }} ** max_scenes} ** max_tracks,

    // Playback state
    queued_scene: [max_tracks]?usize = [_]?usize{null} ** max_tracks,
    open_clip_request: ?OpenClipRequest = null,
    start_playback_request: bool = false,
    reset_playhead_request: bool = false,

    // Undo requests (populated by operations, processed by ui.zig)
    undo_requests: [16]UndoRequest = undefined,
    undo_request_count: usize = 0,

    // Clip move undo (separate since it can involve multiple clips)
    clip_move_requests: [max_tracks * max_scenes]ClipMoveEntry = undefined,
    clip_move_count: usize = 0,
    // Also used to signal ui.zig to move piano clips
    pending_piano_moves: bool = false,

    // Volume drag tracking for undo
    volume_drag_track: ?usize = null,
    volume_drag_start: f32 = 0,

    // Recording state
    recording: RecordingState = .{},
    armed_track: ?usize = null, // Track armed for recording (only one at a time)
    finalize_recording_track: ?usize = null, // Track to finalize notes on
    finalize_recording_scene: ?usize = null, // Scene to finalize notes on
    clear_piano_clip_request: ?OpenClipRequest = null, // Request to clear piano clip notes (for new recordings)

    // Render-time hover tracking (updated during clip slot rendering for accurate hit detection)
    render_hover_track: ?usize = null,
    render_hover_scene: ?usize = null,
    render_hover_has_content: bool = false,

    pub fn init(allocator: std.mem.Allocator) SessionView {
        var self = SessionView{
            .allocator = allocator,
        };

        // Initialize tracks
        for (0..self.track_count) |i| {
            var buf: [16]u8 = undefined;
            const name = std.fmt.bufPrint(&buf, "Inst {d}", .{i + 1}) catch "Inst";
            self.tracks[i] = Track.init(name);
        }

        // Initialize scenes
        for (0..self.scene_count) |i| {
            var buf: [16]u8 = undefined;
            const name = std.fmt.bufPrint(&buf, "{d}", .{i + 1}) catch "1";
            self.scenes[i] = Scene.init(name);
        }

        // Initialize all clips as empty
        for (0..max_tracks) |t| {
            for (0..max_scenes) |s| {
                self.clips[t][s] = .{};
            }
        }

        return self;
    }

    pub fn deinit(self: *SessionView) void {
        self.clipboard.deinit(self.allocator);
    }

    pub fn isSelected(self: *const SessionView, track: usize, scene: usize) bool {
        return self.clip_selected[track][scene];
    }

    pub fn selectClip(self: *SessionView, track: usize, scene: usize) void {
        self.clip_selected[track][scene] = true;
        self.primary_track = track;
        self.primary_scene = scene;
    }

    pub fn deselectClip(self: *SessionView, track: usize, scene: usize) void {
        self.clip_selected[track][scene] = false;
    }

    pub fn clearSelection(self: *SessionView) void {
        for (&self.clip_selected) |*track_sel| {
            for (track_sel) |*sel| {
                sel.* = false;
            }
        }
    }

    pub fn selectAllClips(self: *SessionView) void {
        self.clearSelection();
        for (0..self.track_count) |t| {
            for (0..self.scene_count) |s| {
                if (self.clips[t][s].state != .empty) {
                    self.selectClip(t, s);
                }
            }
        }
    }

    pub fn selectOnly(self: *SessionView, track: usize, scene: usize) void {
        self.clearSelection();
        self.selectClip(track, scene);
    }

    pub fn hasSelection(self: *const SessionView) bool {
        for (self.clip_selected) |track_sel| {
            for (track_sel) |sel| {
                if (sel) return true;
            }
        }
        return false;
    }

    pub fn handleClipClick(self: *SessionView, track: usize, scene: usize, shift_held: bool) void {
        if (shift_held) {
            if (self.isSelected(track, scene)) {
                self.deselectClip(track, scene);
            } else {
                self.selectClip(track, scene);
            }
        } else if (!self.isSelected(track, scene)) {
            self.selectOnly(track, scene);
        } else {
            self.primary_track = track;
            self.primary_scene = scene;
        }
    }

    /// Create a new clip at the given position
    pub fn createClip(self: *SessionView, track: usize, scene: usize) void {
        if (track >= self.track_count or scene >= self.scene_count) return;
        const length_beats = default_clip_bars * beats_per_bar;
        self.clips[track][scene] = .{
            .state = .stopped,
            .length_beats = length_beats,
        };
        // Emit undo request
        if (self.undo_request_count < self.undo_requests.len) {
            self.undo_requests[self.undo_request_count] = .{
                .kind = .clip_create,
                .track = track,
                .scene = scene,
                .length_beats = length_beats,
            };
            self.undo_request_count += 1;
        }
    }

    /// Delete clip at position (reset to empty)
    pub fn deleteClip(self: *SessionView, track: usize, scene: usize) void {
        if (track >= self.track_count or scene >= self.scene_count) return;
        // Capture old state before deleting
        const old_clip = self.clips[track][scene];
        if (old_clip.state == .empty) return; // Don't record deleting empty slots
        self.clips[track][scene] = .{};
        // Emit undo request
        if (self.undo_request_count < self.undo_requests.len) {
            self.undo_requests[self.undo_request_count] = .{
                .kind = .clip_delete,
                .track = track,
                .scene = scene,
                .length_beats = old_clip.length_beats,
                .old_clip = old_clip,
            };
            self.undo_request_count += 1;
        }
    }

    /// Delete all selected clips
    pub fn deleteSelected(self: *SessionView) void {
        for (0..self.track_count) |t| {
            for (0..self.scene_count) |s| {
                if (self.clip_selected[t][s]) {
                    self.deleteClip(t, s);
                }
            }
        }
        self.clearSelection();
    }

    /// Copy selected clips to clipboard
    pub fn copySelected(self: *SessionView) void {
        if (!self.hasSelection()) return;

        // Find min track/scene for relative positioning
        var min_track: usize = max_tracks;
        var min_scene: usize = max_scenes;
        for (0..self.track_count) |t| {
            for (0..self.scene_count) |s| {
                if (self.clip_selected[t][s]) {
                    min_track = @min(min_track, t);
                    min_scene = @min(min_scene, s);
                }
            }
        }

        self.clipboard.clearRetainingCapacity();
        self.clipboard_origin_track = min_track;
        self.clipboard_origin_scene = min_scene;

        for (0..self.track_count) |t| {
            for (0..self.scene_count) |s| {
                if (!self.clip_selected[t][s]) continue;
                const slot = self.clips[t][s];
                // Only copy non-empty clips
                if (slot.state != .empty) {
                    self.clipboard.append(self.allocator, .{
                        .src_track = t,
                        .src_scene = s,
                        .track_offset = @as(i32, @intCast(t)) - @as(i32, @intCast(min_track)),
                        .scene_offset = @as(i32, @intCast(s)) - @as(i32, @intCast(min_scene)),
                        .slot = .{
                            .state = if (slot.state == .playing) .stopped else slot.state,
                            .length_beats = slot.length_beats,
                        },
                    }) catch {};
                }
            }
        }
    }

    /// Cut selected clips (copy + delete)
    pub fn cutSelected(self: *SessionView) void {
        self.copySelected();
        self.deleteSelected();
    }

    /// Paste clips at primary selection position
    pub fn paste(self: *SessionView) void {
        if (self.clipboard.items.len == 0) return;

        self.clearSelection();
        self.piano_copy_count = 0;
        for (self.clipboard.items) |entry| {
            const track_i = @as(i32, @intCast(self.primary_track)) + entry.track_offset;
            const scene_i = @as(i32, @intCast(self.primary_scene)) + entry.scene_offset;

            if (track_i < 0 or scene_i < 0) continue;
            const track: usize = @intCast(track_i);
            const scene: usize = @intCast(scene_i);
            if (track >= self.track_count or scene >= self.scene_count) continue;

            const old_clip = self.clips[track][scene];
            self.clips[track][scene] = entry.slot;
            self.selectClip(track, scene);
            if (self.piano_copy_count < self.piano_copy_requests.len) {
                self.piano_copy_requests[self.piano_copy_count] = .{
                    .src_track = entry.src_track,
                    .src_scene = entry.src_scene,
                    .dst_track = track,
                    .dst_scene = scene,
                };
                self.piano_copy_count += 1;
            }

            if (self.undo_request_count < self.undo_requests.len) {
                self.undo_requests[self.undo_request_count] = .{
                    .kind = .clip_paste,
                    .track = track,
                    .scene = scene,
                    .src_track = entry.src_track,
                    .src_scene = entry.src_scene,
                    .length_beats = entry.slot.length_beats,
                    .old_clip = old_clip,
                };
                self.undo_request_count += 1;
            }
        }
        self.pending_piano_copies = self.piano_copy_count > 0;
    }

    /// Add a new track
    pub fn addTrack(self: *SessionView) bool {
        if (self.track_count >= max_tracks) return false;

        var buf: [16]u8 = undefined;
        const name = std.fmt.bufPrint(&buf, "Inst {d}", .{self.track_count + 1}) catch "Inst";
        self.tracks[self.track_count] = Track.init(name);
        self.track_count += 1;
        // Emit undo request
        if (self.undo_request_count < self.undo_requests.len) {
            self.undo_requests[self.undo_request_count] = .{
                .kind = .track_add,
                .track = self.track_count - 1,
            };
            self.undo_request_count += 1;
        }
        return true;
    }

    /// Add a new scene
    pub fn addScene(self: *SessionView) bool {
        if (self.scene_count >= max_scenes) return false;

        var buf: [16]u8 = undefined;
        const name = std.fmt.bufPrint(&buf, "{d}", .{self.scene_count + 1}) catch "1";
        self.scenes[self.scene_count] = Scene.init(name);
        self.scene_count += 1;
        // Emit undo request
        if (self.undo_request_count < self.undo_requests.len) {
            self.undo_requests[self.undo_request_count] = .{
                .kind = .scene_add,
                .scene = self.scene_count - 1,
            };
            self.undo_request_count += 1;
        }
        return true;
    }

    /// Delete a specific scene (if > 1)
    pub fn deleteScene(self: *SessionView, scene: usize) bool {
        if (self.scene_count <= 1) return false;
        if (scene >= self.scene_count) return false;

        if (self.undo_request_count < self.undo_requests.len) {
            var clip_snapshots: [max_tracks]ClipSnapshot = [_]ClipSnapshot{.{}} ** max_tracks;
            for (0..self.track_count) |t| {
                const slot = self.clips[t][scene];
                clip_snapshots[t] = .{
                    .has_clip = slot.state != .empty,
                    .length_beats = slot.length_beats,
                };
            }
            self.undo_requests[self.undo_request_count] = .{
                .kind = .scene_delete,
                .scene = scene,
                .scene_data = .{
                    .name = self.scenes[scene].name,
                },
                .scene_clips = clip_snapshots,
            };
            self.undo_request_count += 1;
        }

        // Clear selection in this scene
        for (0..self.track_count) |t| {
            self.deselectClip(t, scene);
        }

        // Shift all subsequent scenes down
        for (scene..self.scene_count - 1) |s| {
            self.scenes[s] = self.scenes[s + 1];
            for (0..max_tracks) |t| {
                self.clips[t][s] = self.clips[t][s + 1];
                self.clip_selected[t][s] = self.clip_selected[t][s + 1];
            }
        }

        // Clear the last scene slot
        for (0..max_tracks) |t| {
            self.clips[t][self.scene_count - 1] = .{};
            self.clip_selected[t][self.scene_count - 1] = false;
        }

        self.scene_count -= 1;
        if (self.primary_scene >= self.scene_count) {
            self.primary_scene = self.scene_count - 1;
        }
        return true;
    }

    /// Delete the last scene (if > 1)
    pub fn deleteLastScene(self: *SessionView) bool {
        return self.deleteScene(self.scene_count - 1);
    }

    /// Delete a specific track (if > 1)
    pub fn deleteTrack(self: *SessionView, track: usize) bool {
        if (self.track_count <= 1) return false;
        if (track >= self.track_count) return false;

        if (self.undo_request_count < self.undo_requests.len) {
            var clip_snapshots: [max_scenes]ClipSnapshot = [_]ClipSnapshot{.{}} ** max_scenes;
            for (0..self.scene_count) |s| {
                const slot = self.clips[track][s];
                clip_snapshots[s] = .{
                    .has_clip = slot.state != .empty,
                    .length_beats = slot.length_beats,
                };
            }
            self.undo_requests[self.undo_request_count] = .{
                .kind = .track_delete,
                .track = track,
                .track_data = .{
                    .name = self.tracks[track].name,
                    .volume = self.tracks[track].volume,
                    .mute = self.tracks[track].mute,
                    .solo = self.tracks[track].solo,
                },
                .track_clips = clip_snapshots,
            };
            self.undo_request_count += 1;
        }

        // Clear selection in this track
        for (0..self.scene_count) |s| {
            self.deselectClip(track, s);
        }

        // Shift all subsequent tracks left
        for (track..self.track_count - 1) |t| {
            self.tracks[t] = self.tracks[t + 1];
            for (0..max_scenes) |s| {
                self.clips[t][s] = self.clips[t + 1][s];
                self.clip_selected[t][s] = self.clip_selected[t + 1][s];
            }
        }

        // Clear the last track slot
        for (0..max_scenes) |s| {
            self.clips[self.track_count - 1][s] = .{};
            self.clip_selected[self.track_count - 1][s] = false;
        }

        self.track_count -= 1;
        if (self.primary_track >= self.track_count) {
            self.primary_track = self.track_count - 1;
        }
        return true;
    }

    /// Delete the last track (if > 1)
    pub fn deleteLastTrack(self: *SessionView) bool {
        return self.deleteTrack(self.track_count - 1);
    }

    /// Check if any clip exists in a scene
    pub fn hasClipInScene(self: *const SessionView, scene: usize) bool {
        for (0..self.track_count) |t| {
            if (self.clips[t][scene].state != .empty) return true;
        }
        return false;
    }

    /// Stop all clips (set all non-empty clips to stopped)
    pub fn stopAllInScene(self: *SessionView, scene: usize) void {
        _ = scene;
        for (0..self.track_count) |t| {
            for (0..self.scene_count) |s| {
                if (self.clips[t][s].state != .empty) {
                    self.clips[t][s].state = .stopped;
                }
            }
            self.queued_scene[t] = null;
        }
    }

    /// Move selection with arrow keys
    pub fn moveSelection(self: *SessionView, dx: i32, dy: i32, shift_held: bool) void {
        if (!self.hasSelection() and dx == 0 and dy == 0) return;

        const new_track_i = @as(i32, @intCast(self.primary_track)) + dx;
        const new_scene_i = @as(i32, @intCast(self.primary_scene)) + dy;

        if (new_track_i < 0 or new_track_i >= @as(i32, @intCast(self.track_count))) return;
        if (new_scene_i < 0 or new_scene_i >= @as(i32, @intCast(self.scene_count))) return;

        const new_track: usize = @intCast(new_track_i);
        const new_scene: usize = @intCast(new_scene_i);

        if (shift_held) {
            // Extend selection
            self.selectClip(new_track, new_scene);
        } else {
            // Move selection
            self.selectOnly(new_track, new_scene);
        }
    }

    /// Move selected clips by delta
    pub fn moveSelectedClips(self: *SessionView, delta_track: i32, delta_scene: i32) void {
        if (delta_track == 0 and delta_scene == 0) return;
        if (!self.hasSelection()) return;

        // Collect selected clips and check bounds
        var moves: [max_tracks * max_scenes]struct { from_t: usize, from_s: usize, to_t: usize, to_s: usize } = undefined;
        var move_count: usize = 0;

        for (0..self.track_count) |t| {
            for (0..self.scene_count) |s| {
                if (self.clip_selected[t][s] and self.clips[t][s].state != .empty) {
                    const new_t_i = @as(i32, @intCast(t)) + delta_track;
                    const new_s_i = @as(i32, @intCast(s)) + delta_scene;

                    // Check bounds
                    if (new_t_i < 0 or new_t_i >= @as(i32, @intCast(self.track_count))) return;
                    if (new_s_i < 0 or new_s_i >= @as(i32, @intCast(self.scene_count))) return;

                    moves[move_count] = .{
                        .from_t = t,
                        .from_s = s,
                        .to_t = @intCast(new_t_i),
                        .to_s = @intCast(new_s_i),
                    };
                    move_count += 1;
                }
            }
        }

        if (move_count == 0) return;

        // Clear selection first
        self.clearSelection();

        // Store clips temporarily
        var temp_clips: [max_tracks * max_scenes]ClipSlot = undefined;
        for (moves[0..move_count], 0..) |m, i| {
            temp_clips[i] = self.clips[m.from_t][m.from_s];
            self.clips[m.from_t][m.from_s] = .{}; // Clear source
        }

        // Place clips at new positions
        for (moves[0..move_count], 0..) |m, i| {
            self.clips[m.to_t][m.to_s] = temp_clips[i];
            self.selectClip(m.to_t, m.to_s);
        }

        // Update primary selection
        const new_primary_t = @as(i32, @intCast(self.drag_start_track)) + delta_track;
        const new_primary_s = @as(i32, @intCast(self.drag_start_scene)) + delta_scene;
        if (new_primary_t >= 0 and new_primary_t < @as(i32, @intCast(self.track_count))) {
            self.primary_track = @intCast(new_primary_t);
        }
        if (new_primary_s >= 0 and new_primary_s < @as(i32, @intCast(self.scene_count))) {
            self.primary_scene = @intCast(new_primary_s);
        }
        self.drag_start_track = self.primary_track;
        self.drag_start_scene = self.primary_scene;

        // Emit undo request for clip moves (also signals ui.zig to move piano clips)
        self.clip_move_count = 0;
        for (moves[0..move_count]) |m| {
            if (self.clip_move_count < self.clip_move_requests.len) {
                self.clip_move_requests[self.clip_move_count] = .{
                    .src_track = m.from_t,
                    .src_scene = m.from_s,
                    .dst_track = m.to_t,
                    .dst_scene = m.to_s,
                };
                self.clip_move_count += 1;
            }
        }
        self.pending_piano_moves = true;
    }

    pub fn draw(self: *SessionView, ui_scale: f32, playing: bool, is_focused: bool, playhead_beat: f32) void {
        const row_height = 52.0 * ui_scale;
        const header_height = 32.0 * ui_scale;
        const scene_col_w = 130.0 * ui_scale; // Wider for button + name
        const track_col_w = 160.0 * ui_scale;
        const add_btn_size = 32.0 * ui_scale;

        const grid_pos = zgui.getCursorScreenPos();
        const mouse = zgui.getMousePos();
        const shift_down = selection.isShiftDown();

        // Calculate grid dimensions first (needed for mouse checks)
        const grid_width = scene_col_w + @as(f32, @floatFromInt(self.track_count)) * track_col_w + add_btn_size + 8.0;
        const grid_height = header_height + @as(f32, @floatFromInt(self.scene_count)) * row_height + add_btn_size + 8.0;

        const in_grid = mouse[0] >= grid_pos[0] and mouse[0] < grid_pos[0] + grid_width and
            mouse[1] >= grid_pos[1] and mouse[1] < grid_pos[1] + grid_height;

        // Use render-time hover from previous frame for accurate hit detection
        // (updated during clip slot rendering to match actual cell positions)
        const hover_track = self.render_hover_track;
        const hover_scene = self.render_hover_scene;
        const hover_has_content = self.render_hover_has_content;

        // Reset render-time hover tracking (will be updated during this frame's clip slot rendering)
        self.render_hover_track = null;
        self.render_hover_scene = null;
        self.render_hover_has_content = false;

        // Right-click context menu (handle before left-click selection)
        const ctrl_click = zgui.isMouseClicked(.left) and zgui.io.getKeyCtrl();
        if (in_grid and (zgui.isMouseClicked(.right) or (builtin.os.tag == .macos and ctrl_click))) {
            if (hover_track != null and hover_scene != null) {
                if (hover_has_content) {
                    if (!self.isSelected(hover_track.?, hover_scene.?)) {
                        self.selectOnly(hover_track.?, hover_scene.?);
                    } else {
                        self.primary_track = hover_track.?;
                        self.primary_scene = hover_scene.?;
                    }
                } else {
                    self.clearSelection();
                    self.primary_track = hover_track.?;
                    self.primary_scene = hover_scene.?;
                }
            }
            zgui.openPopup("session_ctx", .{});
        }

        var menu_action = false;
        var popup_open = zgui.isPopupOpen("session_ctx", .{});
        if (zgui.beginPopup("session_ctx", .{})) {
            popup_open = true;
            menu_action = edit_actions.drawMenu(self, .{
                .has_selection = self.hasSelection(),
                .can_paste = self.clipboard.items.len > 0,
            }, .{
                .copy = SessionView.copySelected,
                .cut = SessionView.cutSelected,
                .paste = SessionView.paste,
                .delete = SessionView.deleteSelected,
                .select_all = SessionView.selectAllClips,
            });
            zgui.separator();
            // Delete track/scene options
            var track_label_buf: [48]u8 = undefined;
            const track_del_label = std.fmt.bufPrintZ(&track_label_buf, "Delete Track \"{s}\"", .{self.tracks[self.primary_track].getName()}) catch "Delete Track";
            if (zgui.menuItem(track_del_label, .{ .enabled = self.track_count > 1 })) {
                _ = self.deleteTrack(self.primary_track);
                menu_action = true;
            }
            var scene_label_buf: [48]u8 = undefined;
            const scene_del_label = std.fmt.bufPrintZ(&scene_label_buf, "Delete Scene \"{s}\"", .{self.scenes[self.primary_scene].getName()}) catch "Delete Scene";
            if (zgui.menuItem(scene_del_label, .{ .enabled = self.scene_count > 1 })) {
                _ = self.deleteScene(self.primary_scene);
                menu_action = true;
            }
            zgui.endPopup();
        }

        // Handle mouse release - complete drag move and reset all drag state
        if (!zgui.isMouseDown(.left)) {
            // If we were dragging clips and have a valid target, do the actual move now
            if (self.drag_moving and self.drag_target_track != null and self.drag_target_scene != null) {
                const delta_track = @as(i32, @intCast(self.drag_target_track.?)) - @as(i32, @intCast(self.drag_start_track));
                const delta_scene = @as(i32, @intCast(self.drag_target_scene.?)) - @as(i32, @intCast(self.drag_start_scene));
                if (delta_track != 0 or delta_scene != 0) {
                    self.moveSelectedClips(delta_track, delta_scene);
                }
            }
            self.drag_select.active = false;
            self.drag_select.pending = false;
            self.drag_moving = false;
            self.drag_target_track = null;
            self.drag_target_scene = null;
        }

        // On click, decide: drag move (if over clip with content) or drag select (if over empty)
        if (!popup_open and !menu_action and zgui.isMouseClicked(.left) and in_grid) {
            if (hover_has_content) {
                // Start drag move
                self.drag_moving = true;
                self.drag_start_track = hover_track.?;
                self.drag_start_scene = hover_scene.?;
                self.drag_select.pending = false;
                self.drag_select.active = false;
                // Select this clip
                self.handleClipClick(hover_track.?, hover_scene.?, shift_down);
            } else {
                // Start drag select
                self.drag_select.begin(mouse, shift_down);
                self.drag_moving = false;
                if (hover_track != null and hover_scene != null) {
                    self.primary_track = hover_track.?;
                    self.primary_scene = hover_scene.?;
                }
                if (!shift_down) {
                    self.clearSelection();
                }
            }
        }

        // Update drag select position
        if (self.drag_select.active or self.drag_select.pending) {
            self.drag_select.update(mouse);
        }

        // Activate selection rectangle after drag threshold
        _ = self.drag_select.checkThreshold(4.0);

        // Handle drag moving - track target position for preview (actual move happens on release)
        if (self.drag_moving and zgui.isMouseDragging(.left, 4.0)) {
            zgui.setMouseCursor(.resize_all);
            if (hover_track != null and hover_scene != null) {
                // Just track the target, don't actually move yet
                self.drag_target_track = hover_track;
                self.drag_target_scene = hover_scene;
            }
        }

        // Calculate mixer height for later
        const mixer_height = 200.0 * ui_scale;

        if (!zgui.beginTable("session_grid", .{
            .column = @intCast(self.track_count + 2), // scenes + tracks + add button
            .flags = .{ .borders = .{ .inner_v = true }, .row_bg = false, .sizing = .fixed_fit },
        })) {
            return;
        }

        // Setup columns
        zgui.tableSetupColumn("##scenes", .{ .flags = .{ .width_fixed = true }, .init_width_or_height = scene_col_w });
        for (0..self.track_count) |_| {
            zgui.tableSetupColumn("##track", .{ .flags = .{ .width_fixed = true }, .init_width_or_height = track_col_w });
        }
        zgui.tableSetupColumn("##add_track", .{ .flags = .{ .width_fixed = true }, .init_width_or_height = add_btn_size + 8.0 });

        // Track headers row
        zgui.tableNextRow(.{ .min_row_height = header_height });
        _ = zgui.tableNextColumn(); // Empty corner

        for (0..self.track_count) |t| {
            _ = zgui.tableNextColumn();
            const is_track_selected = self.primary_track == t;
            const text_color = if (is_track_selected) colors.Colors.current.text_bright else colors.Colors.current.text_dim;
            zgui.pushStyleColor4f(.{ .idx = .text, .c = text_color });

            // Make track header clickable
            var track_buf: [32]u8 = undefined;
            const track_label = std.fmt.bufPrintZ(&track_buf, "{s}##track_hdr{d}", .{ self.tracks[t].getName(), t }) catch "Track";
            const track_pad = 4.0 * ui_scale;
            zgui.setCursorPosX(zgui.getCursorPosX() + track_pad);
            if (zgui.selectable(track_label, .{ .selected = is_track_selected, .w = track_col_w - track_pad * 2.0 })) {
                self.primary_track = t;
                self.clearSelection();
            }
            // Right-click on track header opens context menu
            if (zgui.isItemClicked(.right)) {
                self.primary_track = t;
                zgui.openPopup("session_ctx", .{});
            }
            zgui.popStyleColor(.{ .count = 1 });
        }

        // Add track button in header
        _ = zgui.tableNextColumn();
        zgui.pushStyleColor4f(.{ .idx = .button, .c = colors.Colors.current.bg_cell });
        zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = colors.Colors.current.bg_cell_hover });
        zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
        zgui.pushStyleVar2f(.{ .idx = .frame_padding, .v = .{ 10.0 * ui_scale, 6.0 * ui_scale } });
        if (zgui.button("+##add_track", .{})) {
            _ = self.addTrack();
        }
        zgui.popStyleVar(.{ .count = 1 });
        zgui.popStyleColor(.{ .count = 3 });

        // Clip rows
        for (0..self.scene_count) |scene_idx| {
            zgui.tableNextRow(.{ .min_row_height = row_height });

            // Scene column
            _ = zgui.tableNextColumn();
            const row_start_y = zgui.getCursorPosY();
            const draw_list = zgui.getWindowDrawList();

            // Scene launch button first (left side), vertically centered
            const launch_size = 24.0 * ui_scale;
            const vertical_padding = (row_height - launch_size) / 2.0;
            zgui.setCursorPosY(row_start_y + vertical_padding);
            const launch_pos = zgui.getCursorScreenPos();
            var launch_buf: [32]u8 = undefined;
            const launch_id = std.fmt.bufPrintZ(&launch_buf, "##scene_launch{d}", .{scene_idx}) catch "##launch";

            // Check if any clip exists in this scene
            const has_clip_in_scene = self.hasClipInScene(scene_idx);

            zgui.pushStyleColor4f(.{ .idx = .button, .c = colors.Colors.current.bg_panel });
            zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = colors.Colors.current.bg_cell_hover });
            zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
            if (zgui.button(launch_id, .{ .w = launch_size, .h = launch_size })) {
                if (has_clip_in_scene) {
                    self.launchScene(scene_idx, playing);
                } else {
                    self.stopAllInScene(scene_idx);
                }
            }
            zgui.popStyleColor(.{ .count = 3 });

            // Draw play triangle or stop square
            const icon_size = 10.0 * ui_scale;
            const cx = launch_pos[0] + launch_size / 2.0 + 1.0 * ui_scale;
            const cy = launch_pos[1] + launch_size / 2.0;
            if (has_clip_in_scene) {
                // Play triangle
                draw_list.addTriangleFilled(.{
                    .p1 = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                    .p2 = .{ cx - icon_size / 2.0, cy + icon_size / 2.0 },
                    .p3 = .{ cx + icon_size / 2.0, cy },
                    .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.accent),
                });
            } else {
                // Stop square
                draw_list.addRectFilled(.{
                    .pmin = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                    .pmax = .{ cx + icon_size / 2.0, cy + icon_size / 2.0 },
                    .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_dim),
                });
            }

            zgui.sameLine(.{ .spacing = 4.0 * ui_scale });

            // Scene name (clickable to select scene)
            const is_scene_selected = self.primary_scene == scene_idx;
            const scene_text_color = if (is_scene_selected) colors.Colors.current.text_bright else colors.Colors.current.text_dim;
            zgui.pushStyleColor4f(.{ .idx = .text, .c = scene_text_color });

            var scene_buf: [48]u8 = undefined;
            const scene_name = self.scenes[scene_idx].getName();
            const scene_text_size = zgui.calcTextSize(scene_name, .{});
            const frame_padding = zgui.getStyle().frame_padding;
            const selectable_height = scene_text_size[1] + frame_padding[1] * 2.0;
            zgui.setCursorPosY(row_start_y + (row_height - selectable_height) / 2.0);
            const scene_label = std.fmt.bufPrintZ(&scene_buf, "{s}##scene_hdr{d}", .{ scene_name, scene_idx }) catch "Scene";
            if (zgui.selectable(scene_label, .{ .selected = is_scene_selected, .w = scene_col_w - launch_size - 12.0 * ui_scale })) {
                self.primary_scene = scene_idx;
                self.clearSelection();
            }
            // Right-click on scene label opens context menu
            if (zgui.isItemClicked(.right)) {
                self.primary_scene = scene_idx;
                zgui.openPopup("session_ctx", .{});
            }
            zgui.popStyleColor(.{ .count = 1 });

            // Clip slots
            for (0..self.track_count) |track_idx| {
                _ = zgui.tableNextColumn();
                const track_pad = 4.0 * ui_scale;
                zgui.setCursorPosX(zgui.getCursorPosX() + track_pad);
                self.drawClipSlot(track_idx, scene_idx, track_col_w - track_pad * 2.0, row_height - 6.0 * ui_scale, ui_scale, playing, playhead_beat);
            }

            // Empty cell for add track column
            _ = zgui.tableNextColumn();
        }

        // Add scene row
        zgui.tableNextRow(.{ .min_row_height = add_btn_size + 8.0 });
        _ = zgui.tableNextColumn();

        zgui.pushStyleColor4f(.{ .idx = .button, .c = colors.Colors.current.bg_cell });
        zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = colors.Colors.current.bg_cell_hover });
        zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
        zgui.pushStyleVar2f(.{ .idx = .frame_padding, .v = .{ 10.0 * ui_scale, 6.0 * ui_scale } });
        if (zgui.button("+##add_scene", .{})) {
            _ = self.addScene();
        }
        zgui.popStyleVar(.{ .count = 1 });
        zgui.popStyleColor(.{ .count = 3 });

        // Handle keyboard shortcuts (only when this pane is focused)
        const keyboard_free = !zgui.isAnyItemActive();
        const modifier_down = selection.isModifierDown();

        if (is_focused and keyboard_free) {
            edit_actions.handleShortcuts(self, modifier_down, .{
                .has_selection = self.hasSelection(),
                .can_paste = self.clipboard.items.len > 0,
            }, .{
                .copy = SessionView.copySelected,
                .cut = SessionView.cutSelected,
                .paste = SessionView.paste,
                .delete = SessionView.deleteSelected,
                .select_all = SessionView.selectAllClips,
            });

            // Arrow keys for navigation
            if (zgui.isKeyPressed(.left_arrow, true)) {
                self.moveSelection(-1, 0, shift_down);
            }
            if (zgui.isKeyPressed(.right_arrow, true)) {
                self.moveSelection(1, 0, shift_down);
            }
            if (zgui.isKeyPressed(.up_arrow, true)) {
                self.moveSelection(0, -1, shift_down);
            }
            if (zgui.isKeyPressed(.down_arrow, true)) {
                self.moveSelection(0, 1, shift_down);
            }

            // Enter to create clip at selection
            if (zgui.isKeyPressed(.enter, false)) {
                if (self.clips[self.primary_track][self.primary_scene].state == .empty) {
                    self.createClip(self.primary_track, self.primary_scene);
                }
            }
        }


        // Draw selection rectangle if active
        if (self.drag_select.active) {
            const dl = zgui.getForegroundDrawList();
            const fill = .{
                colors.Colors.current.selected[0],
                colors.Colors.current.selected[1],
                colors.Colors.current.selected[2],
                0.2,
            };
            const border = colors.Colors.current.selected;
            self.drag_select.drawClipped(
                dl,
                grid_pos,
                .{ grid_pos[0] + grid_width, grid_pos[1] + grid_height },
                fill,
                border,
            );
        }

        zgui.endTable();

        // Draw mixer strip at bottom of view
        const avail = zgui.getContentRegionAvail();
        if (avail[1] > mixer_height) {
            zgui.setCursorPosY(zgui.getCursorPosY() + avail[1] - mixer_height);
        }

        // Draw mixer using a table to guarantee alignment with grid
        zgui.pushStyleColor4f(.{ .idx = .table_row_bg, .c = colors.Colors.current.bg_header });
        if (zgui.beginTable("mixer_strip", .{
            .column = @intCast(self.track_count + 2),
            .flags = .{ .borders = .{ .inner_v = true }, .row_bg = true, .sizing = .fixed_fit },
        })) {
            // Setup columns to match grid exactly
            zgui.tableSetupColumn("##mix_scenes", .{ .flags = .{ .width_fixed = true }, .init_width_or_height = scene_col_w });
            for (0..self.track_count) |_| {
                zgui.tableSetupColumn("##mix_track", .{ .flags = .{ .width_fixed = true }, .init_width_or_height = track_col_w });
            }
            zgui.tableSetupColumn("##mix_add", .{ .flags = .{ .width_fixed = true }, .init_width_or_height = add_btn_size + 8.0 });

            zgui.tableNextRow(.{ .min_row_height = mixer_height - 8.0 * ui_scale });
            _ = zgui.tableNextColumn(); // Empty scene column

            for (0..self.track_count) |t| {
                _ = zgui.tableNextColumn();
                self.drawTrackMixer(t, track_col_w, mixer_height - 8.0 * ui_scale, ui_scale);
            }

            zgui.endTable();
        }
        zgui.popStyleColor(.{ .count = 1 });
    }

    fn drawClipSlot(self: *SessionView, track: usize, scene: usize, width: f32, height: f32, ui_scale: f32, playing: bool, playhead_beat: f32) void {
        const draw_list = zgui.getWindowDrawList();
        const pos = zgui.getCursorScreenPos();
        const mouse = zgui.getMousePos();

        // Store cell position for ghost rendering
        self.cell_positions[track][scene] = pos;

        const slot = &self.clips[track][scene];
        const is_selected = self.isSelected(track, scene);

        // Check if this clip is being overdubbed (playing + recording)
        const is_overdub_clip = slot.state == .playing and self.recording.track == track and self.recording.scene == scene;

        // Clip colors based on state
        const clip_color = if (is_overdub_clip)
            colors.Colors.current.clip_recording // Use recording color for overdub
        else switch (slot.state) {
            .empty => colors.Colors.current.clip_empty,
            .stopped => colors.Colors.current.clip_stopped,
            .queued => colors.Colors.current.clip_queued,
            .playing => colors.Colors.current.clip_playing,
            .recording => colors.Colors.current.clip_recording,
            .record_queued => colors.Colors.current.clip_queued,
        };

        // Play button dimensions
        const play_btn_w = 24.0 * ui_scale;
        const clip_w = width - play_btn_w - 4.0 * ui_scale;
        const rounding = 3.0 * ui_scale;

        // Check drag select intersection
        if (self.drag_select.active) {
            const clip_min = pos;
            const clip_max = [2]f32{ pos[0] + clip_w, pos[1] + height };
            if (self.drag_select.intersects(clip_min, clip_max)) {
                if (!self.isSelected(track, scene) and slot.state != .empty) {
                    self.selectClip(track, scene);
                }
            }
        }

        // Background
        var bg_color = clip_color;
        if (is_selected) {
            bg_color = .{
                @min(1.0, clip_color[0] + 0.12),
                @min(1.0, clip_color[1] + 0.12),
                @min(1.0, clip_color[2] + 0.12),
                1.0,
            };
        }

        draw_list.addRectFilled(.{
            .pmin = pos,
            .pmax = .{ pos[0] + clip_w, pos[1] + height },
            .col = zgui.colorConvertFloat4ToU32(bg_color),
            .rounding = rounding,
            .flags = zgui.DrawFlags.round_corners_all,
        });

        // Selection border
        if (is_selected) {
            draw_list.addRect(.{
                .pmin = pos,
                .pmax = .{ pos[0] + clip_w, pos[1] + height },
                .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.selected),
                .rounding = rounding,
                .flags = zgui.DrawFlags.round_corners_all,
                .thickness = 2.0,
            });

            // Draw ghost outline at drag target position (if dragging)
            if (self.drag_moving and self.drag_target_track != null and self.drag_target_scene != null) {
                const target_t = self.drag_target_track.?;
                const target_s = self.drag_target_scene.?;
                if (target_t != track or target_s != scene) {
                    // Calculate where this clip would end up relative to the drag target
                    const rel_track = @as(i32, @intCast(track)) - @as(i32, @intCast(self.drag_start_track));
                    const rel_scene = @as(i32, @intCast(scene)) - @as(i32, @intCast(self.drag_start_scene));
                    const final_track = @as(i32, @intCast(target_t)) + rel_track;
                    const final_scene = @as(i32, @intCast(target_s)) + rel_scene;

                    // Only draw if target is in bounds
                    if (final_track >= 0 and final_track < @as(i32, @intCast(self.track_count)) and
                        final_scene >= 0 and final_scene < @as(i32, @intCast(self.scene_count)))
                    {
                        const ghost_pos = self.cell_positions[@intCast(final_track)][@intCast(final_scene)];
                        const ghost_min = ghost_pos;
                        const ghost_max = [2]f32{ ghost_min[0] + clip_w, ghost_min[1] + height };

                        // Draw on foreground so it appears on top
                        const fg_draw_list = zgui.getForegroundDrawList();
                        fg_draw_list.addRectFilled(.{
                            .pmin = ghost_min,
                            .pmax = ghost_max,
                            .col = zgui.colorConvertFloat4ToU32(.{ colors.Colors.current.selected[0], colors.Colors.current.selected[1], colors.Colors.current.selected[2], 0.4 }),
                            .rounding = rounding,
                            .flags = zgui.DrawFlags.round_corners_all,
                        });
                        fg_draw_list.addRect(.{
                            .pmin = ghost_min,
                            .pmax = ghost_max,
                            .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.selected),
                            .rounding = rounding,
                            .flags = zgui.DrawFlags.round_corners_all,
                            .thickness = 2.0,
                        });
                    }
                }
            }
        }

        // Check if we're overdubbing this clip
        const clip_is_overdubbing = slot.state == .playing and self.recording.track == track and self.recording.scene == scene;

        // Clip content indicator (bars) or recording progress
        if (slot.state == .recording) {
            // Show "REC" label for recording clips
            const text_color = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright);
            const rec_label = "REC";
            const rec_size = zgui.calcTextSize(rec_label, .{});
            draw_list.addText(.{ pos[0] + 8.0 * ui_scale, pos[1] + (height - rec_size[1]) / 2.0 }, text_color, rec_label, .{});

            // Draw progress bar at bottom of clip
            if (self.recording.track == track and self.recording.scene == scene) {
                const progress_height = 4.0 * ui_scale;
                const elapsed = playhead_beat - self.recording.start_beat;
                const progress = @min(1.0, @max(0.0, elapsed / self.recording.target_length_beats));
                const progress_width = clip_w * progress;
                draw_list.addRectFilled(.{
                    .pmin = .{ pos[0], pos[1] + height - progress_height },
                    .pmax = .{ pos[0] + progress_width, pos[1] + height },
                    .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.clip_recording),
                });
            }
        } else if (clip_is_overdubbing) {
            // Show "OVERDUB" label when playing and recording
            const text_color = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright);
            const overdub_label = "OVERDUB";
            const overdub_size = zgui.calcTextSize(overdub_label, .{});
            draw_list.addText(.{ pos[0] + 4.0 * ui_scale, pos[1] + (height - overdub_size[1]) / 2.0 }, text_color, overdub_label, .{});
        } else if (slot.state == .record_queued) {
            // Show "ARMED" label for queued recording
            const text_color = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright);
            const armed_label = "ARMED";
            const armed_size = zgui.calcTextSize(armed_label, .{});
            draw_list.addText(.{ pos[0] + 8.0 * ui_scale, pos[1] + (height - armed_size[1]) / 2.0 }, text_color, armed_label, .{});
        } else if (slot.state != .empty) {
            const bars = slot.length_beats / beats_per_bar;
            var buf: [16]u8 = undefined;
            const label = std.fmt.bufPrintZ(&buf, "{d:.0} bars", .{bars}) catch "";
            // Use dark text for all non-empty clips (better contrast on colored backgrounds)
            const text_color = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright);
            const label_size = zgui.calcTextSize(label, .{});
            draw_list.addText(.{ pos[0] + 8.0 * ui_scale, pos[1] + (height - label_size[1]) / 2.0 }, text_color, "{s}", .{label});
        }

        // Invisible button for clip interaction
        var clip_buf: [32]u8 = undefined;
        const clip_id = std.fmt.bufPrintZ(&clip_buf, "##clip_t{d}s{d}", .{ track, scene }) catch "##clip";

        const over_clip = mouse[0] >= pos[0] and mouse[0] < pos[0] + clip_w and
            mouse[1] >= pos[1] and mouse[1] < pos[1] + height;

        // Check if mouse is over the entire cell (clip + play button)
        const over_cell = mouse[0] >= pos[0] and mouse[0] < pos[0] + width and
            mouse[1] >= pos[1] and mouse[1] < pos[1] + height;

        // Update render-time hover tracking for accurate hit detection next frame
        if (over_cell) {
            self.render_hover_track = track;
            self.render_hover_scene = scene;
            self.render_hover_has_content = slot.state != .empty;
        }

        // Show move cursor when hovering over a clip with content (but not recording clips)
        const is_recording_state = slot.state == .recording or slot.state == .record_queued;
        if (over_clip and slot.state != .empty and !is_recording_state and !self.drag_moving) {
            zgui.setMouseCursor(.resize_all);
        }

        // Invisible button for double-click detection
        _ = zgui.invisibleButton(clip_id, .{ .w = clip_w, .h = height });

        // Handle double-click to create/open clip
        if (over_clip and zgui.isMouseDoubleClicked(.left)) {
            if (slot.state == .empty) {
                self.createClip(track, scene);
            }
            self.selectOnly(track, scene);
            self.open_clip_request = .{ .track = track, .scene = scene };
        }

        zgui.sameLine(.{ .spacing = 4.0 * ui_scale });

        // Play/Record button
        const play_pos = zgui.getCursorScreenPos();
        var play_buf: [32]u8 = undefined;
        const play_id = std.fmt.bufPrintZ(&play_buf, "##play_t{d}s{d}", .{ track, scene }) catch "##play";

        const is_playing_clip = slot.state == .playing;
        const is_queued = slot.state == .queued;
        const is_recording = slot.state == .recording;
        const is_record_queued = slot.state == .record_queued;
        const is_empty = slot.state == .empty;
        const is_armed_track = self.armed_track != null and self.armed_track.? == track;
        // Check if we're overdubbing (playing + recording on this clip)
        const is_overdubbing = is_playing_clip and self.recording.track == track and self.recording.scene == scene;

        // Determine button background color
        // For armed track: show record button style for empty slots or stopped clips
        // For recording/record_queued/overdubbing: show recording color
        // Otherwise: normal play button style
        const play_bg = if (is_recording or is_record_queued or is_overdubbing)
            colors.Colors.current.record_armed
        else if (is_playing_clip)
            colors.Colors.current.clip_playing
        else if (is_queued)
            colors.Colors.current.clip_queued
        else if (is_armed_track and (is_empty or slot.state == .stopped))
            colors.Colors.current.record_armed
        else
            colors.Colors.current.bg_cell;

        const hover_bg = if (is_recording or is_record_queued or is_overdubbing or (is_armed_track and (is_empty or slot.state == .stopped)))
            colors.Colors.current.record_armed_hover
        else
            [4]f32{ play_bg[0] + 0.08, play_bg[1] + 0.08, play_bg[2] + 0.08, 1.0 };

        zgui.pushStyleColor4f(.{ .idx = .button, .c = play_bg });
        zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = hover_bg });
        zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
        if (zgui.button(play_id, .{ .w = play_btn_w, .h = height })) {
            // Handle button click based on state
            if (is_recording or is_record_queued or is_overdubbing) {
                // Click on recording/queued/overdubbing clip -> stop recording
                self.armed_track = null;
                if (is_recording) {
                    self.stopRecording(.loop);
                } else if (is_overdubbing) {
                    // Stop overdub - just clear recording state, clip keeps playing
                    self.recording.reset();
                } else {
                    self.cancelRecording();
                }
            } else if (is_armed_track and (is_empty or slot.state == .stopped)) {
                // Click record button on armed track -> start recording
                self.startRecording(track, scene, playing, playhead_beat);
            } else {
                // Normal play/stop behavior
                self.toggleClipPlayback(track, scene, playing);
            }
        }
        zgui.popStyleColor(.{ .count = 3 });

        // Draw play/stop/record icon
        const icon_size = 10.0 * ui_scale;
        const cx = play_pos[0] + play_btn_w / 2.0;
        const cy = play_pos[1] + height / 2.0;

        if (is_recording or is_record_queued or is_overdubbing) {
            // Filled record circle during recording/queued/overdubbing
            draw_list.addCircleFilled(.{
                .p = .{ cx, cy },
                .r = icon_size / 2.0,
            .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright),
        });
        } else if (is_playing_clip) {
            // Stop square (for playing clip)
            draw_list.addRectFilled(.{
                .pmin = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                .pmax = .{ cx + icon_size / 2.0, cy + icon_size / 2.0 },
            .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright),
        });
        } else if (is_queued) {
            // Queued indicator
            draw_list.addTriangleFilled(.{
                .p1 = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                .p2 = .{ cx - icon_size / 2.0, cy + icon_size / 2.0 },
                .p3 = .{ cx + icon_size / 2.0 + 1.0, cy },
                .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.clip_queued),
            });
            draw_list.addTriangle(.{
                .p1 = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                .p2 = .{ cx - icon_size / 2.0, cy + icon_size / 2.0 },
                .p3 = .{ cx + icon_size / 2.0 + 1.0, cy },
                .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.clip_queued),
                .thickness = 2.0,
            });
        } else if (is_armed_track and (is_empty or slot.state == .stopped)) {
            // Record circle for armed track (empty or stopped clips)
            draw_list.addCircleFilled(.{
                .p = .{ cx, cy },
                .r = icon_size / 2.0,
            .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright),
        });
        } else if (is_empty) {
            // Stop square for empty slot on non-armed track
            draw_list.addRectFilled(.{
                .pmin = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                .pmax = .{ cx + icon_size / 2.0, cy + icon_size / 2.0 },
                .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_dim),
            });
        } else {
            // Play triangle (for stopped clip with content)
            draw_list.addTriangleFilled(.{
                .p1 = .{ cx - icon_size / 2.0, cy - icon_size / 2.0 },
                .p2 = .{ cx - icon_size / 2.0, cy + icon_size / 2.0 },
                .p3 = .{ cx + icon_size / 2.0 + 1.0, cy },
                .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_dim),
            });
        }
    }

    fn drawTrackMixer(self: *SessionView, track: usize, width: f32, height: f32, ui_scale: f32) void {
        const padding = 4.0 * ui_scale;
        const spacing = 4.0 * ui_scale;
        const usable_width = width - padding * 2;
        const btn_width = (usable_width - spacing * 2) / 3.0; // 3 buttons: M, S, R
        const btn_height = 36.0 * ui_scale;
        const slider_width = 28.0 * ui_scale;
        const label_height = 24.0 * ui_scale;
        const slider_height = height - btn_height - spacing * 2 - label_height - 4.0 * ui_scale;
        const frame_padding = zgui.getStyle().frame_padding;
        const text_height = zgui.getFontSize();
        const centered_pad_y = @max(0.0, (btn_height - text_height) / 2.0);

        const base_x = zgui.getCursorPosX();
        const base_y = zgui.getCursorPosY();

        // Row 1: M, S, R buttons side by side (fill track width)
        zgui.setCursorPosX(base_x + padding);
        zgui.pushStyleVar2f(.{ .idx = .frame_padding, .v = .{ frame_padding[0], centered_pad_y } });

        // Mute button
        var mute_buf: [32]u8 = undefined;
        const mute_id = std.fmt.bufPrintZ(&mute_buf, "M##mute{d}", .{track}) catch "M";

        const mute_bg = if (self.tracks[track].mute) colors.Colors.current.clip_stopped else colors.Colors.current.bg_cell;
        const mute_text = if (self.tracks[track].mute) colors.Colors.current.text_bright else colors.Colors.current.text_dim;

        zgui.pushStyleColor4f(.{ .idx = .button, .c = mute_bg });
        zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = .{ mute_bg[0] + 0.1, mute_bg[1] + 0.1, mute_bg[2] + 0.1, 1.0 } });
        zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
        zgui.pushStyleColor4f(.{ .idx = .text, .c = mute_text });

        if (zgui.button(mute_id, .{ .w = btn_width, .h = btn_height })) {
            self.tracks[track].mute = !self.tracks[track].mute;
        }
        zgui.popStyleColor(.{ .count = 4 });

        zgui.sameLine(.{ .spacing = spacing });

        // Solo button
        var solo_buf: [32]u8 = undefined;
        const solo_id = std.fmt.bufPrintZ(&solo_buf, "S##solo{d}", .{track}) catch "S";

        const solo_bg = if (self.tracks[track].solo) colors.Colors.current.clip_queued else colors.Colors.current.bg_cell;
        const solo_text = if (self.tracks[track].solo) colors.Colors.current.text_bright else colors.Colors.current.text_dim;

        zgui.pushStyleColor4f(.{ .idx = .button, .c = solo_bg });
        zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = .{ solo_bg[0] + 0.1, solo_bg[1] + 0.1, solo_bg[2] + 0.1, 1.0 } });
        zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
        zgui.pushStyleColor4f(.{ .idx = .text, .c = solo_text });

        if (zgui.button(solo_id, .{ .w = btn_width, .h = btn_height })) {
            self.tracks[track].solo = !self.tracks[track].solo;
        }
        zgui.popStyleColor(.{ .count = 4 });

        zgui.sameLine(.{ .spacing = spacing });

        // Record Arm button
        var arm_buf: [32]u8 = undefined;
        const arm_id = std.fmt.bufPrintZ(&arm_buf, "R##arm{d}", .{track}) catch "R";

        const is_armed = self.armed_track != null and self.armed_track.? == track;
        const arm_bg = if (is_armed) colors.Colors.current.record_armed else colors.Colors.current.bg_cell;
        const arm_text = if (is_armed) colors.Colors.current.text_bright else colors.Colors.current.text_dim;

        zgui.pushStyleColor4f(.{ .idx = .button, .c = arm_bg });
        zgui.pushStyleColor4f(.{ .idx = .button_hovered, .c = if (is_armed) colors.Colors.current.record_armed_hover else .{ arm_bg[0] + 0.1, arm_bg[1] + 0.1, arm_bg[2] + 0.1, 1.0 } });
        zgui.pushStyleColor4f(.{ .idx = .button_active, .c = colors.Colors.current.accent_dim });
        zgui.pushStyleColor4f(.{ .idx = .text, .c = arm_text });

        if (zgui.button(arm_id, .{ .w = btn_width, .h = btn_height })) {
            if (is_armed) {
                // Disarm - also stop any active recording
                if (self.recording.isRecording()) {
                    self.stopRecording(.stop);
                }
                self.armed_track = null;
            } else {
                // Arm this track (disarm any other)
                if (self.recording.isRecording()) {
                    self.stopRecording(.stop);
                }
                self.armed_track = track;
            }
        }
        zgui.popStyleColor(.{ .count = 4 });
        zgui.popStyleVar(.{ .count = 1 });

        // Row 2: Volume slider (centered, wider)
        zgui.setCursorPosY(base_y + btn_height + spacing);
        const slider_x = base_x + (width - slider_width) / 2.0;
        zgui.setCursorPosX(slider_x);

        const slider_screen_pos = zgui.getCursorScreenPos();

        var vol_buf: [32]u8 = undefined;
        const vol_id = std.fmt.bufPrintZ(&vol_buf, "##vol{d}", .{track}) catch "##vol";

        zgui.pushStyleColor4f(.{ .idx = .frame_bg, .c = colors.Colors.current.bg_cell });
        zgui.pushStyleColor4f(.{ .idx = .frame_bg_hovered, .c = colors.Colors.current.bg_cell_hover });
        zgui.pushStyleColor4f(.{ .idx = .frame_bg_active, .c = colors.Colors.current.bg_cell_active });
        zgui.pushStyleColor4f(.{ .idx = .slider_grab, .c = colors.Colors.current.accent });
        zgui.pushStyleColor4f(.{ .idx = .slider_grab_active, .c = colors.Colors.current.accent_dim });

        const volume_before = self.tracks[track].volume;
        _ = zgui.vsliderFloat(vol_id, .{
            .w = slider_width,
            .h = slider_height,
            .v = &self.tracks[track].volume,
            .min = 0.0,
            .max = 1.5,
            .cfmt = "",
        });

        // Track volume drag for undo
        if (zgui.isItemActive()) {
            if (self.volume_drag_track == null) {
                // Drag started
                self.volume_drag_track = track;
                self.volume_drag_start = volume_before;
            }
        } else if (self.volume_drag_track == track) {
            // Drag ended - emit undo request if changed
            if (self.tracks[track].volume != self.volume_drag_start) {
                if (self.undo_request_count < self.undo_requests.len) {
                    self.undo_requests[self.undo_request_count] = .{
                        .kind = .track_volume,
                        .track = track,
                        .old_volume = self.volume_drag_start,
                        .new_volume = self.tracks[track].volume,
                    };
                    self.undo_request_count += 1;
                }
            }
            self.volume_drag_track = null;
        }

        zgui.popStyleColor(.{ .count = 5 });

        // Draw 0dB tick marks on the sides AFTER the slider (so they're visible)
        // Volume = 1.0 is at 1.0/1.5 = 0.667 from bottom
        const draw_list = zgui.getWindowDrawList();
        const zero_db_ratio = 1.0 / 1.5; // 0dB = volume 1.0
        const zero_db_y = slider_screen_pos[1] + slider_height * (1.0 - zero_db_ratio);
        const tick_width = 6.0 * ui_scale;
        const tick_height = 3.0 * ui_scale;
        // Left tick mark
        draw_list.addRectFilled(.{
            .pmin = .{ slider_screen_pos[0] - tick_width - 2.0, zero_db_y - tick_height / 2.0 },
            .pmax = .{ slider_screen_pos[0] - 2.0, zero_db_y + tick_height / 2.0 },
            .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright),
        });
        // Right tick mark
        draw_list.addRectFilled(.{
            .pmin = .{ slider_screen_pos[0] + slider_width + 2.0, zero_db_y - tick_height / 2.0 },
            .pmax = .{ slider_screen_pos[0] + slider_width + tick_width + 2.0, zero_db_y + tick_height / 2.0 },
            .col = zgui.colorConvertFloat4ToU32(colors.Colors.current.text_bright),
        });

        // Row 3: dB label (centered)
        zgui.setCursorPosY(base_y + btn_height + spacing + slider_height + spacing);
        zgui.setCursorPosX(base_x + padding);

        const db = if (self.tracks[track].volume > 0.0001)
            20.0 * @log10(self.tracks[track].volume)
        else
            -60.0;
        var label_buf: [16]u8 = undefined;
        const label = std.fmt.bufPrintZ(&label_buf, "{d:.0}dB", .{db}) catch "";
        zgui.textColored(colors.Colors.current.text_dim, "{s}", .{label});
    }

    fn launchScene(self: *SessionView, scene: usize, playing: bool) void {
        if (playing) {
            // Queue all tracks
            for (0..self.track_count) |t| {
                if (self.recording.track) |rec_track| {
                    if (self.recording.scene) |rec_scene| {
                        if (rec_track == t and rec_scene != scene) {
                            self.stopRecording(.stop);
                        }
                    }
                }
                for (0..self.scene_count) |s| {
                    if (self.clips[t][s].state == .queued) {
                        self.clips[t][s].state = .stopped;
                    }
                }
                if (self.clips[t][scene].state != .empty) {
                    self.clips[t][scene].state = .queued;
                }
                // Always queue the scene switch - this ensures clips in other scenes
                // are stopped even if this track has no clip in the target scene
                self.queued_scene[t] = scene;
            }
        } else {
            // Immediate switch and start playback
            for (0..self.track_count) |t| {
                if (self.recording.track) |rec_track| {
                    if (self.recording.scene) |rec_scene| {
                        if (rec_track == t and rec_scene != scene) {
                            self.stopRecording(.stop);
                        }
                    }
                }
                for (0..self.scene_count) |s| {
                    if (self.clips[t][s].state != .empty) {
                        self.clips[t][s].state = if (s == scene) .playing else .stopped;
                    }
                }
            }
            self.start_playback_request = true;
        }
    }

    fn toggleClipPlayback(self: *SessionView, track: usize, scene: usize, playing: bool) void {
        if (self.recording.track) |rec_track| {
            if (self.recording.scene) |rec_scene| {
                if (rec_track == track and rec_scene != scene) {
                    self.stopRecording(.stop);
                }
            }
        }

        const slot = &self.clips[track][scene];

        self.primary_track = track;
        self.primary_scene = scene;

        // Empty slot = stop this track
        if (slot.state == .empty) {
            self.clearSelection();
            // Stop all clips in this track
            for (0..self.scene_count) |s| {
                if (self.clips[track][s].state == .playing or self.clips[track][s].state == .queued) {
                    self.clips[track][s].state = .stopped;
                }
            }
            self.queued_scene[track] = null;
            return;
        }

        // Also select/focus this clip
        self.selectOnly(track, scene);

        if (slot.state == .playing) {
            slot.state = .stopped;
            self.queued_scene[track] = null;
        } else if (slot.state == .queued) {
            slot.state = .stopped;
            self.queued_scene[track] = null;
        } else if (playing) {
            // Clear other queued
            for (0..self.scene_count) |s| {
                if (self.clips[track][s].state == .queued) {
                    self.clips[track][s].state = .stopped;
                }
            }
            slot.state = .queued;
            self.queued_scene[track] = scene;
        } else {
            // Immediate switch and start playback
            for (0..self.scene_count) |s| {
                if (self.clips[track][s].state != .empty) {
                    self.clips[track][s].state = if (s == scene) .playing else .stopped;
                }
            }
            self.start_playback_request = true;
        }
    }

    /// Process quantized scene switches (called from tick)
    pub fn processQuantizedSwitches(self: *SessionView) void {
        for (0..self.track_count) |track| {
            if (self.queued_scene[track]) |queued| {
                for (0..self.scene_count) |scene| {
                    const state = self.clips[track][scene].state;
                    // Don't touch empty, recording, or record_queued clips
                    if (state != .empty and state != .recording and state != .record_queued) {
                        self.clips[track][scene].state = if (scene == queued) .playing else .stopped;
                    }
                }
                if (track == self.primary_track and queued == self.primary_scene) {
                    self.reset_playhead_request = true;
                }
                self.queued_scene[track] = null;
            }
        }
    }

    /// Start recording on a clip slot
    pub fn startRecording(self: *SessionView, track: usize, scene: usize, playing: bool, playhead_beat: f32) void {
        // If already recording somewhere else, stop it first
        if (self.recording.isRecording()) {
            self.stopRecording(.stop);
        }

        // Create clip if empty, set to recording state
        if (self.clips[track][scene].state == .empty) {
            self.clips[track][scene] = .{
                .state = if (playing) .record_queued else .recording,
                .length_beats = default_clip_bars * beats_per_bar,
            };
            // Request to clear any old notes in the piano clip (new recording, not overdub)
            self.clear_piano_clip_request = .{ .track = track, .scene = scene };
            self.recording.is_new_clip = true;
        } else {
            // Overdub mode - don't clear existing notes
            self.clips[track][scene].state = if (playing) .record_queued else .recording;
            self.recording.is_new_clip = false;
        }

        // Set up recording state
        self.recording.track = track;
        self.recording.scene = scene;
        self.recording.target_length_beats = self.clips[track][scene].length_beats;
        self.recording.note_start_beats = [_]?f32{null} ** 128;
        self.recording.start_beat = 0;
        self.recording.queued_at_beat = playhead_beat;

        if (!playing) {
            // Start immediately - playhead will be reset to 0
            self.start_playback_request = true;
            self.reset_playhead_request = true;
        }

        // Stop any other playing clips on this track and queue this scene
        for (0..self.scene_count) |s| {
            if (s != scene and self.clips[track][s].state == .playing) {
                self.clips[track][s].state = .stopped;
            }
        }
        self.queued_scene[track] = scene;

        // Select and focus this clip
        self.selectOnly(track, scene);
        self.primary_track = track;
        self.primary_scene = scene;

        // Open clip viewer to see recording
        self.open_clip_request = .{ .track = track, .scene = scene };
    }

    /// Stop recording and finalize the clip
    pub fn stopRecording(self: *SessionView, mode: StopRecordingMode) void {
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                // Request finalization of held notes (handled in ui.zig tick)
                if (self.clips[track][scene].state == .recording) {
                    self.finalize_recording_track = track;
                    self.finalize_recording_scene = scene;
                    self.clips[track][scene].state = if (mode == .loop) .playing else .stopped;
                    // Don't reset recording state yet - tick() will handle it after finalizing notes
                    return;
                } else if (self.clips[track][scene].state == .record_queued) {
                    // If still queued, just go back to stopped (no notes to finalize)
                    self.clips[track][scene].state = .stopped;
                }
            }
        }
        // Reset recording state immediately if not actively recording
        self.recording.reset();
    }

    /// Cancel recording without finalizing
    pub fn cancelRecording(self: *SessionView) void {
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                // If the clip was empty before, reset it
                if (self.clips[track][scene].state == .record_queued) {
                    self.clips[track][scene].state = .empty;
                } else if (self.clips[track][scene].state == .recording) {
                    self.clips[track][scene].state = .stopped;
                }
            }
        }
        self.recording.reset();
    }

    /// Process quantized recording start (called from tick at quantize boundary)
    pub fn processRecordingQuantize(self: *SessionView, playhead_beat: f32) void {
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                if (self.clips[track][scene].state == .record_queued) {
                    // Transition to recording state
                    self.clips[track][scene].state = .recording;
                    self.recording.start_beat = playhead_beat;
                }
            }
        }
    }

    /// Check if recording has completed (4 bars elapsed)
    pub fn checkRecordingComplete(self: *SessionView, playhead_beat: f32) bool {
        if (!self.recording.isRecording()) return false;
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                if (self.clips[track][scene].state == .recording) {
                    const elapsed = playhead_beat - self.recording.start_beat;
                    if (elapsed >= self.recording.target_length_beats) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /// Get elapsed recording beats for progress display
    pub fn getRecordingProgress(self: *SessionView, playhead_beat: f32) f32 {
        if (!self.recording.isRecording()) return 0;
        if (self.clips[self.recording.track.?][self.recording.scene.?].state != .recording) return 0;
        const elapsed = playhead_beat - self.recording.start_beat;
        return @min(1.0, elapsed / self.recording.target_length_beats);
    }

    /// Check if we have a recording in record_queued state
    pub fn hasQueuedRecording(self: *SessionView) bool {
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                return self.clips[track][scene].state == .record_queued;
            }
        }
        return false;
    }

    /// Check if we're actively recording (includes overdub mode where clip is playing)
    pub fn isActivelyRecording(self: *SessionView) bool {
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                const state = self.clips[track][scene].state;
                // Recording is active if clip is in recording state OR playing with overdub
                return state == .recording or (state == .playing and self.recording.track != null);
            }
        }
        return false;
    }

    /// Check if we're overdubbing (playing + recording)
    pub fn isOverdubbing(self: *SessionView) bool {
        if (self.recording.track) |track| {
            if (self.recording.scene) |scene| {
                return self.clips[track][scene].state == .playing;
            }
        }
        return false;
    }
};
