const std = @import("std");
const selection = @import("selection.zig");
const constants = @import("session_view/constants.zig");

pub const NameField = struct {
    buf: [32]u8 = undefined,
    len: usize = 0,

    pub fn init(name: []const u8) NameField {
        var field = NameField{};
        field.set(name);
        return field;
    }

    pub fn set(self: *NameField, name: []const u8) void {
        const len = @min(name.len, self.buf.len);
        @memcpy(self.buf[0..len], name[0..len]);
        self.len = len;
    }

    pub fn get(self: *const NameField) []const u8 {
        return self.buf[0..self.len];
    }
};

pub const ClipState = enum {
    empty,
    stopped,
    queued,
    playing,
    recording,
    record_queued,
};

pub const ClipSlot = struct {
    state: ClipState = .empty,
    length_beats: f32 = constants.default_clip_bars * constants.beats_per_bar,
};

pub const Track = struct {
    name: NameField = .{},
    volume: f32 = 0.8,
    mute: bool = false,
    solo: bool = false,

    pub fn init(name: []const u8) Track {
        var t = Track{};
        t.name.set(name);
        return t;
    }

    pub fn setName(self: *Track, name: []const u8) void {
        self.name.set(name);
    }

    pub fn getName(self: *const Track) []const u8 {
        return self.name.get();
    }
};

pub const Scene = struct {
    name: NameField = .{},

    pub fn init(name: []const u8) Scene {
        var s = Scene{};
        s.name.set(name);
        return s;
    }

    pub fn setName(self: *Scene, name: []const u8) void {
        self.name.set(name);
    }

    pub fn getName(self: *const Scene) []const u8 {
        return self.name.get();
    }
};

/// Clipboard entry for clip copy/paste
pub const ClipboardEntry = struct {
    src_track: usize,
    src_scene: usize,
    track_offset: i32,
    scene_offset: i32,
    slot: ClipSlot,
};

pub const PianoCopyRequest = struct {
    src_track: usize,
    src_scene: usize,
    dst_track: usize,
    dst_scene: usize,
};

pub const OpenClipRequest = struct {
    track: usize,
    scene: usize,
};

pub const ClipSnapshot = struct {
    has_clip: bool = false,
    length_beats: f32 = 0,
};

pub const TrackSnapshot = struct {
    name: NameField = .{},
    volume: f32 = 0,
    mute: bool = false,
    solo: bool = false,
};

pub const SceneSnapshot = struct {
    name: NameField = .{},
};

/// Types of undo requests generated by session view operations
pub const UndoRequestKind = enum {
    clip_create,
    clip_delete,
    clip_paste,
    track_add,
    track_delete,
    scene_add,
    scene_delete,
    track_volume,
};

/// Undo request for tracking state changes
pub const UndoRequest = struct {
    kind: UndoRequestKind,
    track: usize = 0,
    scene: usize = 0,
    src_track: usize = 0,
    src_scene: usize = 0,
    length_beats: f32 = 0,
    // For clip_delete: store the old clip state
    old_clip: ClipSlot = .{},
    // For track_volume
    old_volume: f32 = 0,
    new_volume: f32 = 0,
    // For track_delete
    track_data: TrackSnapshot = .{},
    track_clips: [constants.max_scenes]ClipSnapshot = [_]ClipSnapshot{.{}} ** constants.max_scenes,
    // For scene_delete
    scene_data: SceneSnapshot = .{},
    scene_clips: [constants.max_tracks]ClipSnapshot = [_]ClipSnapshot{.{}} ** constants.max_tracks,
};

/// Single clip move for undo
pub const ClipMoveEntry = struct {
    src_track: usize,
    src_scene: usize,
    dst_track: usize,
    dst_scene: usize,
};

/// Tracks the state of an active MIDI recording session
pub const RecordingState = struct {
    track: ?usize = null,
    scene: ?usize = null,
    start_beat: f32 = 0,
    queued_at_beat: f32 = 0,
    target_length_beats: f32 = constants.default_clip_bars * constants.beats_per_bar, // 4 bars
    note_start_beats: [128]?f32 = [_]?f32{null} ** 128, // Track held notes
    note_start_velocities: [128]?f32 = [_]?f32{null} ** 128,
    is_new_clip: bool = false,

    pub fn isRecording(self: *const RecordingState) bool {
        return self.track != null;
    }

    pub fn reset(self: *RecordingState) void {
        self.track = null;
        self.scene = null;
        self.start_beat = 0;
        self.queued_at_beat = 0;
        self.target_length_beats = constants.default_clip_bars * constants.beats_per_bar;
        self.note_start_beats = [_]?f32{null} ** 128;
        self.note_start_velocities = [_]?f32{null} ** 128;
        self.is_new_clip = false;
    }
};

pub const StopRecordingMode = enum {
    stop,
    loop,
};

pub const SessionView = struct {
    allocator: std.mem.Allocator,

    // Grid data
    tracks: [constants.max_tracks]Track = undefined,
    scenes: [constants.max_scenes]Scene = undefined,
    clips: [constants.max_tracks][constants.max_scenes]ClipSlot = undefined,
    track_count: usize = 4,
    scene_count: usize = 8,

    // Selection - simple 2D bool array
    clip_selected: [constants.max_tracks][constants.max_scenes]bool = [_][constants.max_scenes]bool{[_]bool{false} ** constants.max_scenes} ** constants.max_tracks,
    primary_track: usize = 0,
    primary_scene: usize = 0,
    drag_select: selection.DragSelectState = .{},

    // Clipboard
    clipboard: std.ArrayListUnmanaged(ClipboardEntry) = .{},
    clipboard_origin_track: usize = 0,
    clipboard_origin_scene: usize = 0,
    // Piano clip copy requests (processed by ui.zig)
    piano_copy_requests: [constants.max_tracks * constants.max_scenes]PianoCopyRequest = undefined,
    piano_copy_count: usize = 0,
    pending_piano_copies: bool = false,

    // Drag move state
    drag_moving: bool = false,
    drag_start_track: usize = 0,
    drag_start_scene: usize = 0,
    drag_target_track: ?usize = null, // Where clips will move to (preview)
    drag_target_scene: ?usize = null,
    // Cell positions for accurate ghost rendering (updated during clip rendering)
    cell_positions: [constants.max_tracks][constants.max_scenes][2]f32 = [_][constants.max_scenes][2]f32{[_][2]f32{.{ 0, 0 }} ** constants.max_scenes} ** constants.max_tracks,

    // Playback state
    queued_scene: [constants.max_tracks]?usize = [_]?usize{null} ** constants.max_tracks,
    open_clip_request: ?OpenClipRequest = null,
    start_playback_request: bool = false,
    reset_playhead_request: bool = false,

    // Undo requests (populated by operations, processed by ui.zig)
    undo_requests: [16]UndoRequest = undefined,
    undo_request_count: usize = 0,

    // Clip move undo (separate since it can involve multiple clips)
    clip_move_requests: [constants.max_tracks * constants.max_scenes]ClipMoveEntry = undefined,
    clip_move_count: usize = 0,
    // Also used to signal ui.zig to move piano clips
    pending_piano_moves: bool = false,

    // Volume drag tracking for undo
    volume_drag_track: ?usize = null,
    volume_drag_start: f32 = 0,

    // Recording state
    recording: RecordingState = .{},
    armed_track: ?usize = null, // Track armed for recording (only one at a time)
    finalize_recording_track: ?usize = null, // Track to finalize notes on
    finalize_recording_scene: ?usize = null, // Scene to finalize notes on
    clear_piano_clip_request: ?OpenClipRequest = null, // Request to clear piano clip notes (for new recordings)

    // Render-time hover tracking (updated during clip slot rendering for accurate hit detection)
    render_hover_track: ?usize = null,
    render_hover_scene: ?usize = null,
    render_hover_has_content: bool = false,
};
